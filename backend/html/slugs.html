<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>Slug Viewer</title>
	<style>
		/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism-tomorrow&languages=json */
		code[class*=language-],
		pre[class*=language-] {
			color: #ccc;
			background: 0 0;
			font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
			font-size: 1em;
			text-align: left;
			white-space: pre;
			word-spacing: normal;
			word-break: normal;
			word-wrap: normal;
			line-height: 1.5;
			-moz-tab-size: 4;
			-o-tab-size: 4;
			tab-size: 4;
			-webkit-hyphens: none;
			-moz-hyphens: none;
			-ms-hyphens: none;
			hyphens: none
		}

		pre[class*=language-] {
			padding: 1em;
			margin: .5em 0;
			overflow: auto
		}

		:not(pre)>code[class*=language-],
		pre[class*=language-] {
			background: #2d2d2d
		}

		:not(pre)>code[class*=language-] {
			padding: .1em;
			border-radius: .3em;
			white-space: normal
		}

		.token.block-comment,
		.token.cdata,
		.token.comment,
		.token.doctype,
		.token.prolog {
			color: #999
		}

		.token.punctuation {
			color: #ccc
		}

		.token.attr-name,
		.token.deleted,
		.token.namespace,
		.token.tag {
			color: #e2777a
		}

		.token.function-name {
			color: #6196cc
		}

		.token.boolean,
		.token.function,
		.token.number {
			color: #f08d49
		}

		.token.class-name,
		.token.constant,
		.token.property,
		.token.symbol {
			color: #f8c555
		}

		.token.atrule,
		.token.builtin,
		.token.important,
		.token.keyword,
		.token.selector {
			color: #cc99cd
		}

		.token.attr-value,
		.token.char,
		.token.regex,
		.token.string,
		.token.variable {
			color: #7ec699
		}

		.token.entity,
		.token.operator,
		.token.url {
			color: #67cdcc
		}

		.token.bold,
		.token.important {
			font-weight: 700
		}

		.token.italic {
			font-style: italic
		}

		.token.entity {
			cursor: help
		}

		.token.inserted {
			color: green
		}
	</style>
	<style>
		* {
			font-family: monospace !important;
		}

		html,
		body {
			background-color: #2d2d2d;
			margin: 0;
			width: 100% !important;
			height: 100% !important;
		}

		text {
			position: fixed;
			top: 1%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: #DEDEDE
		}

		a {
			color: inherit !important
		}

		div {
			width: 100%;
			height: 100%;
		}

		pre {
			background-color: #f4f4f4;
			padding: 10px;
			overflow-x: auto
		}
	</style>
</head>

<body>
	<text><a href="#feather-icons">Feather Icons</a> <a href="#simple-icons">Simple Icons</a> <a
			href="#octicons">Octicons</a></text>
	<div id="code-container"></div>

	<script>
		/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism-tomorrow&languages=json */
		var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {}, Prism = function (e) { var n = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, t = 0, r = {}, a = { manual: e.Prism && e.Prism.manual, disableWorkerMessageHandler: e.Prism && e.Prism.disableWorkerMessageHandler, util: { encode: function e(n) { return n instanceof i ? new i(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ") }, type: function (e) { return Object.prototype.toString.call(e).slice(8, -1) }, objId: function (e) { return e.__id || Object.defineProperty(e, "__id", { value: ++t }), e.__id }, clone: function e(n, t) { var r, i; switch (t = t || {}, a.util.type(n)) { case "Object": if (i = a.util.objId(n), t[i]) return t[i]; for (var l in r = {}, t[i] = r, n) n.hasOwnProperty(l) && (r[l] = e(n[l], t)); return r; case "Array": return i = a.util.objId(n), t[i] ? t[i] : (r = [], t[i] = r, n.forEach((function (n, a) { r[a] = e(n, t) })), r); default: return n } }, getLanguage: function (e) { for (; e;) { var t = n.exec(e.className); if (t) return t[1].toLowerCase(); e = e.parentElement } return "none" }, setLanguage: function (e, t) { e.className = e.className.replace(RegExp(n, "gi"), ""), e.classList.add("language-" + t) }, currentScript: function () { if ("undefined" == typeof document) return null; if ("currentScript" in document) return document.currentScript; try { throw new Error } catch (r) { var e = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack) || [])[1]; if (e) { var n = document.getElementsByTagName("script"); for (var t in n) if (n[t].src == e) return n[t] } return null } }, isActive: function (e, n, t) { for (var r = "no-" + n; e;) { var a = e.classList; if (a.contains(n)) return !0; if (a.contains(r)) return !1; e = e.parentElement } return !!t } }, languages: { plain: r, plaintext: r, text: r, txt: r, extend: function (e, n) { var t = a.util.clone(a.languages[e]); for (var r in n) t[r] = n[r]; return t }, insertBefore: function (e, n, t, r) { var i = (r = r || a.languages)[e], l = {}; for (var o in i) if (i.hasOwnProperty(o)) { if (o == n) for (var s in t) t.hasOwnProperty(s) && (l[s] = t[s]); t.hasOwnProperty(o) || (l[o] = i[o]) } var u = r[e]; return r[e] = l, a.languages.DFS(a.languages, (function (n, t) { t === u && n != e && (this[n] = l) })), l }, DFS: function e(n, t, r, i) { i = i || {}; var l = a.util.objId; for (var o in n) if (n.hasOwnProperty(o)) { t.call(n, o, n[o], r || o); var s = n[o], u = a.util.type(s); "Object" !== u || i[l(s)] ? "Array" !== u || i[l(s)] || (i[l(s)] = !0, e(s, t, o, i)) : (i[l(s)] = !0, e(s, t, null, i)) } } }, plugins: {}, highlightAll: function (e, n) { a.highlightAllUnder(document, e, n) }, highlightAllUnder: function (e, n, t) { var r = { callback: t, container: e, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; a.hooks.run("before-highlightall", r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), a.hooks.run("before-all-elements-highlight", r); for (var i, l = 0; i = r.elements[l++];)a.highlightElement(i, !0 === n, r.callback) }, highlightElement: function (n, t, r) { var i = a.util.getLanguage(n), l = a.languages[i]; a.util.setLanguage(n, i); var o = n.parentElement; o && "pre" === o.nodeName.toLowerCase() && a.util.setLanguage(o, i); var s = { element: n, language: i, grammar: l, code: n.textContent }; function u(e) { s.highlightedCode = e, a.hooks.run("before-insert", s), s.element.innerHTML = s.highlightedCode, a.hooks.run("after-highlight", s), a.hooks.run("complete", s), r && r.call(s.element) } if (a.hooks.run("before-sanity-check", s), (o = s.element.parentElement) && "pre" === o.nodeName.toLowerCase() && !o.hasAttribute("tabindex") && o.setAttribute("tabindex", "0"), !s.code) return a.hooks.run("complete", s), void (r && r.call(s.element)); if (a.hooks.run("before-highlight", s), s.grammar) if (t && e.Worker) { var c = new Worker(a.filename); c.onmessage = function (e) { u(e.data) }, c.postMessage(JSON.stringify({ language: s.language, code: s.code, immediateClose: !0 })) } else u(a.highlight(s.code, s.grammar, s.language)); else u(a.util.encode(s.code)) }, highlight: function (e, n, t) { var r = { code: e, grammar: n, language: t }; if (a.hooks.run("before-tokenize", r), !r.grammar) throw new Error('The language "' + r.language + '" has no grammar.'); return r.tokens = a.tokenize(r.code, r.grammar), a.hooks.run("after-tokenize", r), i.stringify(a.util.encode(r.tokens), r.language) }, tokenize: function (e, n) { var t = n.rest; if (t) { for (var r in t) n[r] = t[r]; delete n.rest } var a = new s; return u(a, a.head, e), o(e, a, n, a.head, 0), function (e) { for (var n = [], t = e.head.next; t !== e.tail;)n.push(t.value), t = t.next; return n }(a) }, hooks: { all: {}, add: function (e, n) { var t = a.hooks.all; t[e] = t[e] || [], t[e].push(n) }, run: function (e, n) { var t = a.hooks.all[e]; if (t && t.length) for (var r, i = 0; r = t[i++];)r(n) } }, Token: i }; function i(e, n, t, r) { this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || "").length } function l(e, n, t, r) { e.lastIndex = n; var a = e.exec(t); if (a && r && a[1]) { var i = a[1].length; a.index += i, a[0] = a[0].slice(i) } return a } function o(e, n, t, r, s, g) { for (var f in t) if (t.hasOwnProperty(f) && t[f]) { var h = t[f]; h = Array.isArray(h) ? h : [h]; for (var d = 0; d < h.length; ++d) { if (g && g.cause == f + "," + d) return; var v = h[d], p = v.inside, m = !!v.lookbehind, y = !!v.greedy, k = v.alias; if (y && !v.pattern.global) { var x = v.pattern.toString().match(/[imsuy]*$/)[0]; v.pattern = RegExp(v.pattern.source, x + "g") } for (var b = v.pattern || v, w = r.next, A = s; w !== n.tail && !(g && A >= g.reach); A += w.value.length, w = w.next) { var E = w.value; if (n.length > e.length) return; if (!(E instanceof i)) { var P, L = 1; if (y) { if (!(P = l(b, A, e, m)) || P.index >= e.length) break; var S = P.index, O = P.index + P[0].length, j = A; for (j += w.value.length; S >= j;)j += (w = w.next).value.length; if (A = j -= w.value.length, w.value instanceof i) continue; for (var C = w; C !== n.tail && (j < O || "string" == typeof C.value); C = C.next)L++, j += C.value.length; L--, E = e.slice(A, j), P.index -= A } else if (!(P = l(b, 0, E, m))) continue; S = P.index; var N = P[0], _ = E.slice(0, S), M = E.slice(S + N.length), W = A + E.length; g && W > g.reach && (g.reach = W); var z = w.prev; if (_ && (z = u(n, z, _), A += _.length), c(n, z, L), w = u(n, z, new i(f, p ? a.tokenize(N, p) : N, k, N)), M && u(n, w, M), L > 1) { var I = { cause: f + "," + d, reach: W }; o(e, n, t, w.prev, A, I), g && I.reach > g.reach && (g.reach = I.reach) } } } } } } function s() { var e = { value: null, prev: null, next: null }, n = { value: null, prev: e, next: null }; e.next = n, this.head = e, this.tail = n, this.length = 0 } function u(e, n, t) { var r = n.next, a = { value: t, prev: n, next: r }; return n.next = a, r.prev = a, e.length++, a } function c(e, n, t) { for (var r = n.next, a = 0; a < t && r !== e.tail; a++)r = r.next; n.next = r, r.prev = n, e.length -= a } if (e.Prism = a, i.stringify = function e(n, t) { if ("string" == typeof n) return n; if (Array.isArray(n)) { var r = ""; return n.forEach((function (n) { r += e(n, t) })), r } var i = { type: n.type, content: e(n.content, t), tag: "span", classes: ["token", n.type], attributes: {}, language: t }, l = n.alias; l && (Array.isArray(l) ? Array.prototype.push.apply(i.classes, l) : i.classes.push(l)), a.hooks.run("wrap", i); var o = ""; for (var s in i.attributes) o += " " + s + '="' + (i.attributes[s] || "").replace(/"/g, "&quot;") + '"'; return "<" + i.tag + ' class="' + i.classes.join(" ") + '"' + o + ">" + i.content + "</" + i.tag + ">" }, !e.document) return e.addEventListener ? (a.disableWorkerMessageHandler || e.addEventListener("message", (function (n) { var t = JSON.parse(n.data), r = t.language, i = t.code, l = t.immediateClose; e.postMessage(a.highlight(i, a.languages[r], r)), l && e.close() }), !1), a) : a; var g = a.util.currentScript(); function f() { a.manual || a.highlightAll() } if (g && (a.filename = g.src, g.hasAttribute("data-manual") && (a.manual = !0)), !a.manual) { var h = document.readyState; "loading" === h || "interactive" === h && g && g.defer ? document.addEventListener("DOMContentLoaded", f) : window.requestAnimationFrame ? window.requestAnimationFrame(f) : window.setTimeout(f, 16) } return a }(_self); "undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism);
		Prism.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: !0, greedy: !0 }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: !0, greedy: !0 }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, Prism.languages.webmanifest = Prism.languages.json;

	</script>
	<script>
		var rx_escapable = /[\\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

		var gap,
			indent,
			meta = { // table of character substitutions
				'\b': '\\b',
				'\t': '\\t',
				'\n': '\\n',
				'\f': '\\f',
				'\r': '\\r',
				'"': '\\"',
				'\\': '\\\\'
			},
			rep;

		function quote(string) {

			// If the string contains no control characters, no quote characters, and no
			// backslash characters, then we can safely slap some quotes around it.
			// Otherwise we must also replace the offending characters with safe escape
			// sequences.

			rx_escapable.lastIndex = 0;
			return rx_escapable.test(string)
				? '"' + string.replace(rx_escapable, function (a) {
					var c = meta[a];
					return typeof c === 'string'
						? c
						: '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
				}) + '"'
				: '"' + string + '"';
		}


		function str(key, holder, limit) {

			// Produce a string from holder[key].

			var i,          // The loop counter.
				k,          // The member key.
				v,          // The member value.
				length,
				mind = gap,
				partial,
				value = holder[key];

			// If the value has a toJSON method, call it to obtain a replacement value.

			if (value && typeof value === 'object' &&
				typeof value.toJSON === 'function') {
				value = value.toJSON(key);
			}

			// If we were called with a replacer function, then call the replacer to
			// obtain a replacement value.

			if (typeof rep === 'function') {
				value = rep.call(holder, key, value);
			}

			// What happens next depends on the value's type.

			switch (typeof value) {
				case 'string':
					return quote(value);

				case 'number':

					// JSON numbers must be finite. Encode non-finite numbers as null.

					return isFinite(value)
						? String(value)
						: 'null';

				case 'boolean':
				case 'null':

					// If the value is a boolean or null, convert it to a string. Note:
					// typeof null does not produce 'null'. The case is included here in
					// the remote chance that this gets fixed someday.

					return String(value);

				// If the type is 'object', we might be dealing with an object or an array or
				// null.

				case 'object':

					// Due to a specification blunder in ECMAScript, typeof null is 'object',
					// so watch out for that case.

					if (!value) {
						return 'null';
					}

					// Make an array to hold the partial results of stringifying this object value.

					gap += indent;
					partial = [];

					// Is the value an array?

					if (Object.prototype.toString.apply(value) === '[object Array]') {

						// The value is an array. Stringify every element. Use null as a placeholder
						// for non-JSON values.

						length = value.length;
						for (i = 0; i < length; i += 1) {
							partial[i] = str(i, value, limit) || 'null';
						}

						// Join all of the elements together, separated with commas, and wrap them in
						// brackets.

						v = partial.length === 0
							? '[]'
							: gap
								? (
									gap.length + partial.join(', ').length + 4 > limit ?
										'[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
										'[ ' + partial.join(', ') + ' ]'
								)
								: '[' + partial.join(',') + ']';
						gap = mind;
						return v;
					}

					// If the replacer is an array, use it to select the members to be stringified.

					if (rep && typeof rep === 'object') {
						length = rep.length;
						for (i = 0; i < length; i += 1) {
							if (typeof rep[i] === 'string') {
								k = rep[i];
								v = str(k, value, limit);
								if (v) {
									partial.push(quote(k) + (
										gap
											? ': '
											: ':'
									) + v);
								}
							}
						}
					} else {

						// Otherwise, iterate through all of the keys in the object.

						for (k in value) {
							if (Object.prototype.hasOwnProperty.call(value, k)) {
								v = str(k, value, limit);
								if (v) {
									partial.push(quote(k) + (
										gap
											? ': '
											: ':'
									) + v);
								}
							}
						}
					}

					// Join all of the member texts together, separated with commas,
					// and wrap them in braces.

					v = partial.length === 0
						? '{}'
						: gap
							? (
								gap.length + partial.join(', ').length + 4 > limit ?
									'{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
									'{ ' + partial.join(', ') + ' }'
							)
							: '{' + partial.join(',') + '}';
					gap = mind;
					return v;
			}
		}


		function beautify(value, replacer, space, limit) {

			// The stringify method takes a value and an optional replacer, and an optional
			// space parameter, and returns a JSON text. The replacer can be a function
			// that can replace values, or an array of strings that will select the keys.
			// A default replacer method can be provided. Use of the space parameter can
			// produce text that is more easily readable.

			var i;
			gap = '';
			indent = '';

			if (!limit) limit = 0;

			if (typeof limit !== "number")
				throw new Error("beaufifier: limit must be a number");

			// If the space parameter is a number, make an indent string containing that
			// many spaces.

			if (typeof space === 'number') {
				for (i = 0; i < space; i += 1) {
					indent += ' ';
				}

				// If the space parameter is a string, it will be used as the indent string.

			} else if (typeof space === 'string') {
				indent = space;
			}

			// If there is a replacer, it must be a function or an array.
			// Otherwise, throw an error.

			rep = replacer;
			if (replacer && typeof replacer !== 'function' &&
				(typeof replacer !== 'object' ||
					typeof replacer.length !== 'number')) {
				throw new Error('beautifier: wrong replacer parameter');
			}

			// Make a fake root object containing our value under the key of ''.
			// Return the result of stringifying the value.

			return str('', { '': value }, limit);
		}
	</script>
	<script>
		const codeContainer = document.getElementById('code-container');

		// Fetch the code snippets from the API
		fetch('/api/badge/slugs')
			.then(response => response.json())
			.then(data => {
				// Create a <pre> element to hold the code
				const pre = document.createElement('pre');
				pre.textContent = beautify(data, null, 2);
				pre.classList.add("language-json")

				// Highlight the code using Prism.js
				Prism.highlightElement(pre);

				// Append the <pre> element to the container
				codeContainer.appendChild(pre);

				document.querySelectorAll(".property").forEach(icon => {
					icon.setAttribute("id", icon.innerHTML.replaceAll("\"", ""))
				})
			})
			.catch(error => {
				console.error('Error:', error);
			});
	</script>
</body>

</html>